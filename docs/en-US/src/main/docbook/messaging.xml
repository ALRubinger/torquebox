<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="messaging">
  <title>Messaging</title>

  <section>
    <title>Message Broker</title>

    <section>
      <title>Basics</title>

      <para>A message broker is simply a service that facilitates asynchronous
      message-passing between application components.</para>
    </section>

    <section>
      <title>HornetQ</title>

      <para>TorqueBox integrates the JBoss HornetQ message broker technology.
      It is automatically available to you, with no additional configuration
      required to start the messaging service. HornetQ supports clustered
      messaging, to allow for load-balancing, failover, and other advanced
      deployments.</para>
    </section>

    <section>
      <title>Producers and Consumers</title>

      <para>While some components may be purely a producer, or purely a
      consumer, the roles are not mutually exclusive. Many components may
      rightly play multiple roles, consuming and producing messages in the act
      of performing its actions.</para>

      <section>
        <title>Producers</title>

        <para>Any component or client code that creates messages and gives
        them to the message broker for delivery is considered a
        <glossterm>producer</glossterm>. Generally speaking, the producer does
        not know the details of the destination.</para>
      </section>

      <section>
        <title>Consumers</title>

        <para>Any component that waits for messages to be delivered to it by
        the message broker is consider a <glossterm>consumer</glossterm>. A
        consumer is unaware of the producer and any other consumers,
        potentially.</para>
      </section>
    </section>

    <section>
      <title>Queues and Topics</title>

      <para>The message broker supports two different delivery semantics,
      referred to as <glossterm>queues</glossterm> and
      <glossterm>topics</glossterm>, which are specialization of the generic
      idea of <glossterm>destinations</glossterm>.</para>

      <section>
        <title>Destinations</title>

        <para>A destination represents a place a message producer sends
        messages. From the producer's point-of-view, every destination,
        whether a queue or a topic, is simply a place to deposit messages.
        From the consumer's point-of-view, every destination, whether a queue
        or a topic, is simply a place to pick up messages.</para>

        <para>The specific semantics of a destination, while important in the
        design of application components, does not necessary affect how
        individual producers or consumers are created. The topology of how
        messages flow between them is defined outside of the scope of any
        individual producer or consumer.</para>

        <para>In all cases, a destination may be fed messages from multiple
        producers.</para>
      </section>

      <section>
        <title>Queues</title>

        <para>A queue is a destination that allows multiple consumers to
        withdraw messages from it, but each message is delivered to exactly
        one consumer. Imagine a bank with multiple customer service windows,
        but a single line. As each bank teller becomes available, the next
        person in line goes to the next open window. In this scenario, the
        window tellers are the consumers, and the line of customers waiting
        service represent the queue of messages.</para>

        <para>While a single consumer is allowed to consume each message,
        multiple producers may be responsible for placing messages into the
        queue.</para>
      </section>

      <section>
        <title>Topics</title>

        <para>A topic is a destination that sends a copy of a message to all
        interested consumers. Presentations at conferences may be thought of
        as topics. Each audience member has expressed interest in a particular
        topic, and the message producers are the presenters at the front of
        the hall.</para>

        <para>Multiple consumers receive the same message, and multiple
        producers may be adding messages to the topic.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Deploying Destinations</title>

    <para>Queues and topics (collectively known as destinations) may be
    deployed with with your application, or separate from your application.
    Additionally, various parts of your application may also implicitly deploy
    and use some destinations.</para>

    <para>Each method has advantages and disadvantages involving the
    expectations of your application and its interaction with resources
    outside the scope of the application.</para>

    <section>
      <title>Deployment Styles</title>

      <section>
        <title>Deploying destinations with your application</title>

        <para>If you decide to deploy your queues and topics with your
        application, you automatically align their lifecycle to the deployment
        cycle of your application. If you undeploy your application, your
        queues and topics will also disappear, and be unable to receive
        messages. If the queues are used only internally to your application,
        and short lifespan semantics are useful to you, deploying destinations
        with your application reduces deployment steps and moving
        parts.</para>
      </section>

      <section>
        <title>Deploying destinations apart from your application</title>

        <para>If you deploy destinations separate and apart from your
        application, they become long-lived first-class component citizens in
        your environment. Applications may be deployed and undeployed, while
        the destinations continue to function, accepting and processing
        messages to the best of their ability.</para>

        <para>If the consumers to a destination are offline, the destination
        may persist and store any unhandled messages until a consumer
        re-attaches.</para>

        <para>The downside is that by making destinations first-class
        top-level components of your environment, you must also manage, deploy
        and undeploy them separate from any app, creating additional
        work.</para>
      </section>
    </section>

    <section>
      <title>Deployment Descriptors</title>

      <para>Deploying queues and topics is as easy as creating simple
      YAML files, and placing them either in your application's
      <filename>config/</filename> directory, or in the application
      server's <filename>deploy/</filename> directory, depending on
      which deployment style you've chosen. Both methods may be
      combined.  Server-deployed destinations and application-deployed
      destinations are indistinguishable once deployed.</para>

      <section>
        <title><filename>queues.yml</filename></title>

        <para>To deploy queues, a simple YAML file is required, simply naming
        the queue, and providing additional configuration parameters.
        Currently, no additional configuration parameters are allowed.</para>

        <para><example>
            <title>queues.yml</title>

            <para><programlisting format="">/queues/my_queue:

/queues/my_other_queue:

</programlisting>The name of the queue will be used when registering the queue
            in the naming-service, and is used to discover the queue for
            attaching consumers and producers.</para>

            <para>By convention, queues are named with the prefix of
            <filename>/queues</filename>.</para>
          </example></para>
      </section>

      <section>
        <title><filename>topics.yml</filename></title>

        <para>To deploy topics, a simple YAML file is required, simply naming
        the topic, and providing additional configuration parameters.
        Currently, no additional configuration parameters are allowed.</para>

        <para><example>
            <title>topics.yml</title>

            <para><programlisting format="">/topics/my_topic:

/topics/my_other_topic:

</programlisting>The name of the queue will be used when registering the topic
            in the naming-service, and is used to discover the topic for
            attaching consumers and producers.</para>

            <para>By convention, topics are named with the prefix of
            <filename>/topics</filename>.</para>
          </example></para>
      </section>
    </section>
  </section>

  <section>
    <title>Ruby Consumers</title>

    <para>Message consumers may be implemented in Ruby and easily attached to
    destinations. A Ruby consumer may either interact at the lowest JMS-level,
    or take advantage of higher-level semantics.</para>

    <section>
      <title>Low-level message consumption</title>

      <para>For the lowest-level implementation of a Ruby consumer, the class
      must simply implement <function>process!(msg)</function> which
      receives a <classname>javax.jms.Message</classname> as its parameter.
      Admittedly, this gets quite a lot of Java in your Ruby, but it's
      available if needed.</para>

      <para><example>
          <title>Low-level message consumer</title>

          <para><programlisting format="">class MyLowConsumer
  def process!(msg)
    # manipulate the javax.jms.Message here
  end
end</programlisting></para>
        </example></para>
    </section>

    <section>
      <title>Syntactic sugar for Text-based messages</title>

      <para>
        For simple text-based messages, a consumer may extend
        <classname>TorqueBox::Messaging::MessageProcessor</classname>
        and implement an <function>on_message(text)</function> method
        which will receive the text payload of the message.
      </para>

      <para>
        <example>
          <title>Text-based message consumer</title>

          <para><programlisting format="">class MyTextConsumer &lt; TorqueBox::Messaging::MessageProcessor
  def on_message(text)
    # process the string `text` payload
    # the JMS message is available as a member variable called <function>message()</function>
  end
end</programlisting>
          </para>
          <para>
            There is an accessor for the actual JMS message that is
            set by TorqueBox prior to invoking
            <function>on_message</function>, so it's there if you need
            it.
          </para>

        </example>
      </para>
    </section>

    <section>
      <title>Connecting Consumers to Destinations</title>

      <para>You can connect consumers hosted within a TorqueBox-based
      application, or in external scripts. The method for each environment is
      similar, but slightly different, since TorqueBox-hosted consumers get
      more baked-in support from the container.</para>

      <section>
        <title>Connecting consumers within TorqueBox</title>

        <para>To connect consumers within a TorqueBox-deployed
        application, you need to create a
        <filename>messaging.yml</filename> file, such as
        <filename>config/messaging.yml</filename> for Rails
        applications.</para>

        <para>
          This file will contain the mappings from your destinations
          (topics and queues) to your consumers.  The configuration
          file is a YAML hash, the keys of which are your destination
          names, which should correspond to the entries in either
          <filename>queues.yml</filename> or
          <filename>topics.yml</filename>.
        </para>

        <example>
          <title>messaging.yml</title>
          <para>
            <programlisting format="">/queues/foo: MyFooHandler
/topics/baz: MyBazHandler</programlisting>
          </para>
          <para>
            The classes MyFooHandler and MyBazHandler would correspond
            to files available on the load path: my_foo_handler.rb and
            my_baz_handler.rb, respectively.  In a Rails app, these
            files would typically reside beneath
            <filename>lib/</filename> or
            <filename>app/models/</filename>.
          </para>
        </example>

        <para>
          The above example shows the simplest possible configuration,
          but it's possible to specify filtering criteria and
          special-purpose configuration of your handlers as well using
          the keys <parameter>filter</parameter> and
          <parameter>config</parameter>, respectively.  The
          <parameter>filter</parameter> parameter may be used to
          filter the messages dispatched to your consumer.  The
          <parameter>config</parameter> parameter should contain a
          hash of data which will be passed to your consumer's
          <function>configure(hash)</function> prior to invoking
          <function>process!</function>.
        </para>

        <example>
          <title>messaging.yml with config and filter options set</title>
          <para>
            <programlisting format="">/queues/foo:
  MyFooHandler:
    filter: "cost &gt; 30"
    config:
      type: "premium"
      season: "fall"</programlisting>
          </para>
          <para>
            Because the structure of the file is <ulink
            url="http://www.yaml.org">YAML</ulink>, proper indentation
            is required.
          </para>
        </example>

        <section>
          <title>Connecting Consumers outside of TorqueBox</title>

          <para>
            To support messaging outside of TorqueBox, i.e. outside of
            the JBoss Application Server (AS), two command-line
            utilities are provided: one that can deploy your
            <filename>queues.yml</filename> (or
            <filename>topics.yml</filename>) and one that can deploy
            your <filename>messaging.yml</filename> config file.
          </para>

          <para>
            <example>
              <title>Deploying your Consumers outside of the App Server</title>
              
              <para><programlisting format="">$ trq-message-processor-host --deploy messaging.yml
              </programlisting></para>
              <para>Optionally, you can pass <code>-N
              your.naming.host</code> if there's not a naming server
              running locally</para>
            </example>
          </para>

          <para>
            Firing up the consumers doesn't do much good without the actual destinations, though...
          </para>

          <para>
            <example>
              <title>Deploying your Destinations outside of the App Server</title>
              
              <para><programlisting format="">$ trq-message-broker -s --deploy queues.yml
              </programlisting></para>
              <para>The <code>-s</code> option tells the broker to
              fire up its own naming service.  Otherwise, it attempts
              to use a local one.</para>
            </example>
          </para>

        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Ruby Producers</title>
    
    <para>
      The TorqueBox messaging client is evolving rapidly, and we're
      focused on better encapsulation of the more obtuse aspects of
      JMS.  But for the time being, direct manipulation of JMS classes
      via JRuby is the best way to put a message on a queue or topic.
    </para>

    <example>
      <title>A simple script that queues a text message</title>
      
      <para><programlisting format="">#!/usr/bin/env jruby

require 'rubygems'
require 'org.torquebox.torquebox-messaging-client'

TorqueBox::Messaging::Client.connect do |session|
  queue    = session.createQueue( '/queues/foo' )
  producer = session.createProducer( queue )
  message  = session.createTextMessage( "The time is #{Time.now}" )
  producer.send( message )
  session.commit
 end</programlisting>
      </para>

      <para>
        The session passed to the block is the actual
        <classname>javax.jms.Session</classname> instance.  Although
        it's possible to run the above code in say, a Rails controller
        action, TorqueBox <emphasis>tasks</emphasis> are a much better
        alternative.
      </para>
    </example>

  </section>

  <section id="async-tasks">
    <title>Tasks</title>

    <para>A special case of message queues is to execute some task
    asynchronously, perhaps even remotely. Rails developers often want
    to spawn a potentially long-running task in response to a user
    request, without forcing the user to wait for its
    completion. TorqueBox makes this easy.</para>

    <section>
      <title>Task Classes</title>

      <para>Task classes simply extend
      <classname>TorqueBox::Messaging::Task</classname> and implement
      one or more (usually long-running) methods that take a single
      object payload, a Ruby <classname>Hash</classname>.</para>

      <para>In Rails applications, these tasks should be placed in the
      <filename>app/tasks/</filename> directory, and be named with a
      suffix of <filename>_task.rb</filename> on the file, and a
      suffix of <classname>Task</classname> on the class name.</para>

      <para>Any of the task's methods can be invoked asynchronously by
      calling the task's class method, <function>async</function>.</para>

      <para><example>
    <title>Example task class</title>

    <para><programlisting format="">class EmailerTask &lt; TorqueBox::Messaging::Task
  def send_welcome(payload)
    to = "#{payload[:name]} &lt;#{payload[:address]}&gt;"
    # send welcome email to the user
  end

  def send_password_reset(payload)
    email = payload[:address]
    # send password-reset email to the user
  end
end</programlisting></para>
      </example></para>

    </section>

    <section>
      <title>Invoke a task</title>

      <para>Tasks can be invoked asynchronously from within any
      application running inside TorqueBox, e.g. your Rails
      app.</para>

      <para><example>
    <title>Spawning a task from a Rails controller</title>

    <para><programlisting format="">class UserController &lt; ApplicationController
  def register
    user = User.new(params[:user])
    ...
    EmailerTask.async(:send_welcome, :address =&gt; user.email, :name =&gt; user.name)
  end
  def reset_password
    ...
    EmailerTask.async(:send_password, :address =&gt; params[:email])
  end
end</programlisting>The first parameter to the <function>async(...)</function> class
method is a symbol indicating the method to execute asynchronously.
Optional hash pairs comprising the payload of the message follow.</para>
      </example></para>
    </section>

  </section>
</chapter>
